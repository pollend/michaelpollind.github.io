<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://pollend.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://pollend.github.io//" rel="alternate" type="text/html" /><updated>2019-01-29T19:39:51-08:00</updated><id>https://pollend.github.io//feed.xml</id><title type="html">Michael Pollind</title><subtitle>Michael Pollind
</subtitle><entry><title type="html">Ardunio, Avr and Scons</title><link href="https://pollend.github.io//2019/01/29/ardunio-avr-scons.html" rel="alternate" type="text/html" title="Ardunio, Avr and Scons" /><published>2019-01-29T19:14:00-08:00</published><updated>2019-01-29T19:14:00-08:00</updated><id>https://pollend.github.io//2019/01/29/ardunio-avr-scons</id><content type="html" xml:base="https://pollend.github.io//2019/01/29/ardunio-avr-scons.html">&lt;p&gt;The Arduino IDE is a really good starting environment but I was looking for something a bit more flexible. 
Atmel studio is built for AVR chips but the environment obscures a lot of the process and adding an Ardunio library prevents the IDE 
from properly building the binary and working out how to fix the build was just too much of a hassle. This configuration allows the use of other 
environments besides the Ardunio IDE such as &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Vscode&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/clion/&quot;&gt;Clion&lt;/a&gt;. 
Scons is a build system centered around python and can be easily configured to produce the correct binaries for AVR using avr-gcc, avr-g++, and avr-objcopy. The basic process is 
to compile the source using the avr-g++, avr-gcc and then converting the compiled object files to ihex.
The build process can also produce the necessary .hex files that can be flashed with &lt;a href=&quot;https://www.microchip.com/mplab/mplab-integrated-programming-environment&quot;&gt;Mplab IPE&lt;/a&gt; or avrdude.&lt;/p&gt;

&lt;p&gt;The scons build is split up into two sections. setting up the AVR environment and then building the final hex file. Any additional libraries are just submodules in the 3rdparty folder. this first part sets up the environment along with the correct build configurations such as the avr compiler and the processor that this source will compile to. &lt;code&gt;Device&lt;/code&gt; is set to whatever the associated device that will be compiled for. &lt;code&gt;CPU_FREQUENCY&lt;/code&gt; will define the frequency that the processor is configured for. The actual frequency is defined by the fuse bits that will have to be set.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;env = Environment()

# Set environment for AVR-GCC.
env['CC'] = 'avr-gcc'
env['CXX'] = 'avr-g++'
env['AS'] = 'avr-gcc'
env['CPPPATH'] = ['/usr/avr/include/', 'build']
env['OBJCOPY'] = 'avr-objcopy'
env['SIZE'] = 'avr-size'
env.Append(CCFLAGS = '-Os -Wall -Werror -flto')

# Declare some variables about microcontroller.
# Microcontroller type.
DEVICE = 'atmega328'
# Microcontroller frequency.
CPU_FREQUENCY = '8000000UL' # Hz


# Set environment for an Atmel AVR Atmega 328p microcontroller.
# Create and initialize the environment.
env.Append(CCFLAGS = '-mmcu=' + DEVICE)
env.Append(LINKFLAGS = '-mmcu=' + DEVICE)
env.Append(LINKFLAGS = '-Wl,-u,vfprintf -lprintf_min')
env.Append(LINKFLAGS = '-lm')
env.Append(CPPDEFINES = 'F_CPU=' + CPU_FREQUENCY)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The second section after this is just compiling the necessary code. In this case I’m using Minicore along with the Wire library and SD card library. the basic process is just to include all the necessary source files and defined the correct header locations. I could of separated Minicore into a static library along with the other libraries and link that separately but the compile times are so quick that it’s not really necessary. its fairly easy to include other submodules and modify the build with other libraries.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Define target name.
TARGET = 'build/main'

# Define source file.
env.Append(CPPPATH=[
    'src',
    '3rdparty/MiniCore/avr/cores/MCUdude_corefiles/',
    '3rdparty/MiniCore/avr/libraries/Wire/src/',
    '3rdparty/MiniCore/avr/libraries/SPI/src/',
    '3rdparty/SD/src/',
    '3rdparty/MiniCore/avr/variants/standard'])
wiring_pulse = env.Object(
    target = '3rdparty/MiniCore/avr/cores/MCUdude_corefiles/wiring_pulse_1.o',
    source = '3rdparty/MiniCore/avr/cores/MCUdude_corefiles/wiring_pulse.S')
sources = [
    Glob('./main.cpp'),
    Glob(&quot;3rdparty/MiniCore/avr/cores/MCUdude_corefiles/*.cpp&quot;),
    Glob(&quot;3rdparty/MiniCore/avr/cores/MCUdude_corefiles/*.c&quot;),
    Glob(&quot;3rdparty/MiniCore/avr/libraries/Wire/src/*/*.c&quot;),
    Glob(&quot;3rdparty/MiniCore/avr/libraries/Wire/src/*.cpp&quot;),
    Glob(&quot;3rdparty/MiniCore/avr/libraries/SPI/src/*.cpp&quot;),
    Glob(&quot;3rdparty/SD/src/*/*.cpp&quot;),
    Glob(&quot;3rdparty/SD/src/*.cpp&quot;),
    wiring_pulse]

# Build the program.
# Default() is used so that when running scons only sources are
# compiled and linked- no other commands (see below) are run

Default(env.Program(target = TARGET + '.elf', source = sources))

# Create hex binary file.
Default(env.Command(TARGET + '.hex', TARGET + '.elf', env['OBJCOPY'] + ' -O ihex $SOURCE $TARGET'))

# Compute memory usage.
Default(env.Command(None, TARGET + '.elf', env['SIZE'] + ' -C --mcu=' + DEVICE + ' $SOURCE'))
Default(env.Command(None, None, 'ctags -R -f src/.tags src'))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;build-template-source&quot;&gt;Build Template: &lt;a href=&quot;https://github.com/GaitRehabilitation/avr_ardunio_template&quot;&gt;source&lt;/a&gt;&lt;/h2&gt;</content><author><name></name></author><summary type="html">The Arduino IDE is a really good starting environment but I was looking for something a bit more flexible. Atmel studio is built for AVR chips but the environment obscures a lot of the process and adding an Ardunio library prevents the IDE from properly building the binary and working out how to fix the build was just too much of a hassle. This configuration allows the use of other environments besides the Ardunio IDE such as Vscode and Clion. Scons is a build system centered around python and can be easily configured to produce the correct binaries for AVR using avr-gcc, avr-g++, and avr-objcopy. The basic process is to compile the source using the avr-g++, avr-gcc and then converting the compiled object files to ihex. The build process can also produce the necessary .hex files that can be flashed with Mplab IPE or avrdude.</summary></entry><entry><title type="html">Micro Logger V1.0 (ICM-20498)</title><link href="https://pollend.github.io//2018/11/18/micro-logger-v1-0-icm-20498.html" rel="alternate" type="text/html" title="Micro Logger V1.0 (ICM-20498)" /><published>2018-11-18T23:04:00-08:00</published><updated>2018-11-18T23:04:00-08:00</updated><id>https://pollend.github.io//2018/11/18/micro-logger-v1-0-icm-20498</id><content type="html" xml:base="https://pollend.github.io//2018/11/18/micro-logger-v1-0-icm-20498.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;The Micro Logger is a small wearable sensor that logs gyro and acceleration data directly to an SD card. This first design was kept very simple and the footprint was minimized down as much as possible. Going forward, there are some basic plans to replace the sd card with an e.mmc module and solder the connections of the battery directly to the board with a charging IC. This should make it possible to charge battery through a micro-usb interface. Variations of this in the future can explore different mem sensors and compare characteristic performance.&lt;/p&gt;
&lt;h2 id=&quot;hardware&quot;&gt;Hardware&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://sites.chapman.edu/soangra/files/2018/11/Screenshot_20181117_002654-12glz3o.png&quot; alt=&quot;Micro Logger&quot; height=&quot;auto&quot; width=&quot;20%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This implementation of the sensor uses an &lt;a href=&quot;https://www.invensense.com/products/motion-tracking/9-axis/icm-20948&quot;&gt;ICM-20498&lt;/a&gt; and a i2c bridge(&lt;a href=&quot;http://www.ti.com/lit/ds/symlink/pca9306.pdf&quot;&gt;PCA9306DCUR&lt;/a&gt;). Due to the lower running voltage of the mems sensor a separate drop out is used to bring the voltage down to 1.8v vs the 3.3v that is running the micro processor. The signals from the mems sensor are passed through an &lt;a href=&quot;https://www.mouser.com/ProductDetail/Microchip-Technology-Atmel/ATMEGA328-AU?qs=sGAEpiMZZMvqv2n3s2xjse40PngS4U1x0lh%252bvvDKKQk%3d&quot;&gt;ATMEGA-328-AU&lt;/a&gt; running &lt;a href=&quot;https://github.com/MCUdude/MicroCore&quot;&gt;MicroCore&lt;/a&gt; before being saved to an SD card. The 2x3 header on the board is an ISP programming header for flashing the processor. A board level schematic can be found here: &lt;a href=&quot;https://sites.chapman.edu/soangra/files/2018/10/micro_logger-287fha3.pdf&quot;&gt;Schematic&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Some tweaks to the design include changing the the resistors on the i2c line and testing if it’s possible to increase the frequency. The ATMEGA328-AU is already fairly small but Microchip also sell a variation of the same processor in a flat-package variant; This could help with minimizing the size of the board.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;software&quot;&gt;Software&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/UKQB0AQtzkLAy3trR0bVvPspVhcSC9gn2UAZNo2z88yInSNjwv7RPYvIaLRJ5z2YhRBh4OHqOhEmZSeX9SMuFAsUwmkCiilkT1IGzoCvdMrI7FxCaFJ6_C8YbEF4iZYj4uo3BehSbCX-iIUoqaFq9ETzk_pk7xMMrW98SJKqcUZnyn50b236aeMRvvpzGjsqVI5oM99etDq6tRjvJmjPU8wTDmMio8J7lR-mYPyxm8ML2RWyNZQYwrXvqPMk61tF7x2g17q74hi_YU-qPoYkXqJwyxbVl0vC2T6EFIVtYlHeLX_jOjH7no9nCohUppFRRkx0UL_FPlvpPLe2hH5lyh4URnP6nmjlYNLVaSfgLcN3OJ16VrVByb_UwKjkh92y2yxAnX_wn9dnKHzUicwRtzIa6xy-rU2XHNhLBLN1pt--IY5blEReVyRbvxgMnIuh_E_-fJaL0c-zqOAFhxv2yZ72KUGxHjpF7tSIsJYwtcXI-uN5y4RPliPKHTBLGBh3f1mhHa6dX0ofyOBxZ-pfRxa40R-BkCDN9k_xI8IYiGQBUduEfjnRACP-tLTq8M-PKm9kKUI8lLECYJtAuuSSaAll7YtQnp-8lVyMcmG2qwfNC3zZAmHirmjSk1jgEqQcOLP_KVTTdYGNudB_dLdkaM78=w1795-h848-no&quot; alt=&quot;Programming&quot; width=&quot;438&quot; height=&quot;207&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It’s possible to load up a more custom program for a specialty task through the open ISP header on the board. A pogo pin adapter should make the process of re-flashing the processor easier (&lt;a href=&quot;https://www.sparkfun.com/products/11591&quot;&gt;pogo adapter&lt;/a&gt;). The github repository contains all the necessary code for a basic logger.&lt;/p&gt;

&lt;p&gt;The SD card library that comes default with ardunio is horribly slow. I plan to exchange this with SdFat along with storing the data to a binary format. this should allow more data to be stored  and the smaller format should allow for a high frequency.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/GaitRehabilitation/mini_data_capture/tree/ICM-20948&quot;&gt;Project Files&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction The Micro Logger is a small wearable sensor that logs gyro and acceleration data directly to an SD card. This first design was kept very simple and the footprint was minimized down as much as possible. Going forward, there are some basic plans to replace the sd card with an e.mmc module and solder the connections of the battery directly to the board with a charging IC. This should make it possible to charge battery through a micro-usb interface. Variations of this in the future can explore different mem sensors and compare characteristic performance. Hardware</summary></entry></feed>